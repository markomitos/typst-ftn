= Имплементација подршке за _Keras_ 3

== Анализа имплементације проблема компатибилности

Архитектонска промена библиотеке _Keras_ из верзије 2 у верзију 3, описана у поглављу
Библиотека _Keras_, је разлог проблема компатибилности библиотеке унутар радног окружења TFF.
Функција tff.learning.from\_keras\_model, била је дизајнирана да очекује
и користи унутрашње API позиве специфичне за Keras 2 (нпр. за директно издвајање
_statefull_ променљивих оптимизатора). Пошто Keras 3 не подржава ове позиве,
директна интеграција је постала немогућа.

Анализа TFF кода показала је да би потпуна миграција целог радног окружења TFF-а на _Keras_ 3
архитектуру била претерано сложена и ризиковала би нарушавање функционалности постојећег,
верификованог кода који се ослања на библиотеку _Keras_ 2. Стога је донета одлука
да се имплементира паралелна подршка за обе верзије библиотеке _Keras_. Овај приступ
је захтевао да се TFF функције модификују тако да могу да рукују и са _Keras_ 2 и са _Keras_ 3
компонентама истовремено.

Паралерлна подршка за обе верзије библиотеке _Keras_ подразумева два примарна техничка
захтева који су формирали оквир рефакторисања:

- Подршка за унију типова: Функције у TFF-у морају бити у стању да прихвате објекте који су или _Keras_ 2 или _Keras_ 3 типови. Ово је решено имплементацијом уније типова за улазне параметре модела, метрика и функција грешке.

- Апстракција логике руковања стањем: Креирање засебног механизма који би, на основу верзије _Keras_ објекта, вратио одговарајуће променљиве (нпр. из _stateful_ _Keras_ 2 или _stateless_ _Keras_ 3 API-ја). Ова потреба је директно довела до развоја посебне компоненте keras\_compat.

Рефакторисање се фокусирало на додавање логике компатибилности у кључне TFF
модуле (_models_, _optimizers_, _metrics_), омогућавајући рад са обе верзије библиотеке _Keras_,
чиме је изазов миграције претворен у изазов апстракције.

#pagebreak()

== Архитектура рефакторисања

Већина рефакторисаног кода се налази унутар сегмента радног окружења TFF који је
имплементиран у програмском језику _Python_ @python. Унутар _Python_ имплементације
се налази секција _learning_ у којој се налази код одговоран за алгоритме за федеративно учење,
као и модули _models_, _optimizers_ и _metrics_, који рукују понашањем модела током обучавања @tff.

Модул _models_ представља најважнију тачку за интеграцију _Keras_ модела у TFF.
Његова примарна улога енкапсулација логике _Keras_ модела у TFF-ов интерфејс
tff.learning.Model. TFF интерфејс дефинише потребне атрибуте и методе које су кључне
за FL процес, укључујући: обучиве променљиве (_trainable variables_),
необучиве променљиве (_non-trainable variables_), променљиве стања модела
(_model state variables_), методу forward\_pass за прослеђивање података кроз модел
и методу report\_local\_unfinalized\_metrics за прикупљање локалних статистика @tff.

Модул _optimizers_ садржи логику неопходну за дефинисање и управљање оптимизаторима клијената
(_client optimizers_). У федеративном учењу, оптимизатори имају клијентску и серверску улогу.
На клијентској страни се користе за израчунавање локалних ажурирања модела на основу локалних
података. Њихово стање, које укључује променљиве попут импулса (_momentum_) или
адаптивних стопа учења (_adaptive learning rates_) мора бити укључено у стање сервера
(_server state_). Овај модул обезбеђује да TFF може исправно да серијелизује и десеријелизује
стање оптимизатора приликом дистрибуције и агрегације, омогућавајући континуирано учење
током FL рунди @tff. Промене у понашању _Keras_ 3 оптимизатора директно утичу на то како овај модул
приступа њиховим променљивим стањима.

Модул metrics је одговоран за израчунавање, прикупљање и агрегацију статистичких мера перформанси
модела, као што су тачност (_accuracy_) и губитак (_loss_) током процеса федеративног учења.
У радном окружењу TFF, метрике се деле на две фазе: нефинализоване метрике и финализоване метрике.
Клијенти израчунавају нефинализоване метрике (сирове вредности, као што су укупна сума губитака и
број обрађених примера) и враћају их серверу. Овај модул садржи логику за агрегацију
нефинализованих метрика преко свих клијената, као и логику за њихову финализацију
(нпр. израчунавање просечне вредности)  @tff. Прелазак _Keras_ 3 метрика на _stateless_ парадигму
је захтевао рефакторисање модула, како би се обезбедило исправно извлачење и враћање
нефинализованих тензора неопходних за централизовану агрегацију на серверу.
